1.1变量与常量
package main
import "fmt"
// 全局变量
var name string
var age int
// 批量声明
var (
    sex    string
    grade  int
    number int
)
// 常量声明用const
const pi = 3.1415926
// 命名多个常量
const (
    e = 2.7
    g = 9.8
)
const (
    // b与c后都没赋值,默认同上,如此处c和b值都与a相同
    a = 10
    b
    c
)
/*iota关键字,仅能在常量中使用,再const关键字,就会被重置为0,每新增一行,常量加1
可以用于实现枚举
*/
const (
    d = iota
    f
    h
)
// _可以用于接收用不到的返回值,或者用于跳过一行,即该行存在,但是用不到
const (
    n1 = iota
    n2
    _
    n4
)
func main() {
    // 变量赋值
    name = "xiaoming"
    age = 12
    fmt.Println(name, age)
    sex = "男"
    grade = 2
    number = 30
    fmt.Println(sex, ",", grade, "年级, 学号", number)
    // 定义时就赋值,编译器可以通过赋值类型推到类型,所以可以不写类型
    var name2 string = "xiaohong"
    var age2 int = 13
    fmt.Println(name2, age2)
    // 批量声明赋值
    var name3, age3 = "xiaohei", 20
    fmt.Println(name3, age3)
    // 短变量声明 ->仅在函数中定义
    m := 10
    fmt.Println("质量", m)
    // 常量
    fmt.Println("pi:", pi)
    // 命名多个常量的时候,第一行赋值,后面的省略,后面的值会同上
    fmt.Println(a, b, c)
    fmt.Println(d, f, h)
    fmt.Println(n1, n2, n4) // 0 1 3
}
1.2基本数据类型
package main
import (
    "fmt"
    "math"
    "strings"
)
func main() {
    // 十进制打印为二进制
    n := 10
    fmt.Printf("%b\n", n)
    // 8进制
    m := 075
    fmt.Printf("%d\n", m)
    // 16进制
    o := 0xff
    fmt.Printf("%d\n", o)
    // uint与int(前者是正整数,后者是整数)
    var age uint8  // 默认值0
    var grade int8 // 默认值0
    fmt.Println(age)
    fmt.Println(grade)
    // float类型
    var n1 float32
    var n2 float64
    fmt.Println(n1, n2) // 默认值均为0
    fmt.Println(math.MaxFloat32)
    fmt.Println(math.MaxFloat64)
    // 布尔值,默认值为false,数字类型无法转换为bool
    var b bool
    fmt.Println("布尔值默认值:", b)
    b = true
    fmt.Println(b)
    // 字符串,双引号
    s1 := "zifuchuan"
    fmt.Println(s1)
    // 特殊字符
    // 换行符->跳转到下一行的同一位置
    fmt.Println("\t制表符\n换行符")
    // 多行字符串
    s2 := `两个反引号
中间的内容
会远洋输出
\n
\t
`
    fmt.Println(s2)
    //字符串的常用操作
    s3 := "abc"
    s4 := "hello,你好"
    fmt.Println(len(s3))
    fmt.Println(len(s4))
    // 拼接字符串
    s5 := s3 + s4
    fmt.Println(s5)
    s5 = fmt.Sprintf("%s - %s", s3, s4) // 前面传入拼接格式
    s5 = s3 + "~" + s4
    fmt.Println(s5)
    // 字符串分割
    fmt.Println(strings.Split(s4, ","))
    // 字符类型(两种): byte(uint8的别名) 仅够ASCII,rune(int32的别名)
    var c1 byte = 'c'
    var c2 rune = 'c'
    fmt.Println(c1,c2)
    fmt.Printf("c1:%T,c2:%T",c1,c2)
    fmt.Println()
    // 字符串循环输出
    var f string = "hello,中国"
    for i := 0; i < len(f); i++ {
        fmt.Printf("%c\n",f[i])
    }
    fmt.Println()
    // 上面的打印中文会乱码,所以处理中英文混合的就要使用range循环
    for _, r := range f {
        // r循环中取出的,f循环的字符串
        fmt.Printf("%c\n",r)
    }
}
1.3逻辑判断
package main
import "fmt"
func main() {
    // if判断
    // 基本写法
    var score = 65
    if score >= 90 {
        fmt.Println("A")
    } else if score > 75 {
        fmt.Println("B")
    } else {
        fmt.Println("C")
    }
    // 特殊写法,此处的score尽在if中生效
    if score = 65; score >= 90 {
        fmt.Println("A")
    } else if score > 75 {
        fmt.Println("B")
    } else {
        fmt.Println("C")
    }
    // for循环
    // 基本样式
    for i := 0; i < 10; i++ {
        fmt.Println(i)
    }
    // 省略初始语句(需要在上方定义),必须保留初始语句后的 ;
    var i = 1
    for ; i < 10; i++ {
        fmt.Println(i)
    }
    // 省略初始语句合结束语句,类似java中的while
    fmt.Println("---------------")
    var t = 1
    for t < 5 {
        fmt.Println("t")
        t++
    }
    // 无限循环
    /*for {
        fmt.Println("abc")
    }*/
    // break,跳出循环
    for s := 0; s < 10; s++ {
        if s > 5 {
            // 跳出循环
            break
            // 跳出本次循环
            //continue
        }
        fmt.Println(s)
    }
    // switch
    expr := 3
    switch expr {
    case 1:
        fmt.Println(expr)
    case 2:
        fmt.Println(expr)
    case 3:
        fmt.Println("逮到")
    }
    // case使用表达式
    age := 18
    switch {
    case age < 18:
        fmt.Println("禁止进入网吧")
    case age >= 18:
        fmt.Println("可以进入网吧")
    }
}
2.1数组
package main
import "fmt"
/**
数组:数组是值类型,也就是初始化完成后,讲数据加入数组或者将数组作为值赋值仅仅是一个值的copy过程,不会发生变化
*/
func main() {
    var array1 [3]int
    var array2 [4]int
    fmt.Println(array1)
    fmt.Println(array2)
    // 数组的初始化
    // 定义时使用初始值列表的方式初始化
    var city = [4]string{"北京", "上海", "广州", "深圳"}
    fmt.Println(city)
    // 让编译器推导数组长度
    var boolArray = [...]bool{true, false, true, false}
    fmt.Println(boolArray)
    // 使用索引值初始化
    var langArray = [...]string{1: "Golang", 2: "Java", 7: "JS"}
    fmt.Println(langArray)
    // 数组不同的长度就是不同的类型
    fmt.Printf("%T\n", langArray)
    //数组循环
    for i := range city {
        fmt.Println(city[i])
    }
    for _, s := range langArray {
        fmt.Println(s)
    }
    for i := 0; i < len(boolArray); i++ {
        fmt.Println(boolArray[i])
    }
    // 多维数组,只有最外层数组可以让编译器推导长度,即写为[...]
    var citys = [3][2]string{{"郑州", "洛阳"}, {"杭州", "绍兴"}, {"北京", "上海"}}
    for i := range citys {
        fmt.Println(citys[i][0])
    }
    for _, value := range citys {
        for _, v := range value {
            fmt.Println("城市:", v)
        }
    }
    var homework1 = [...]int{1, 2, 3, 4, 5}
    result := 0
    for _, v := range homework1 {
        result += v
    }
    fmt.Println(result)
    var homework2 = [...]int{1, 3, 5, 7, 8}
    for i, v := range homework2 {
        if i == len(homework2)-1 {
            break
        }
        for j := i + 1; j < len(homework2); j++ {
            if v+homework2[j] == 8 {
                fmt.Print("(",i,",", j,")")
            }
        }
    }
}
2.2切片
package main
import "fmt"
// 切片 与数组最大的不同就是不用初始化长度
func main() {
    var a []int
    var b []string
    var c []bool
    // 初始化时需要加上=
    var d = []bool{false, true}
    fmt.Println(a)
    fmt.Println(b)
    fmt.Println(c)
    fmt.Println(d)
    // 基于数组定义切片
    var num = [5]int{1, 2, 3, 4, 8}
    // 左闭右开,切从数组中获取切片,容量是从起始位置到末尾的长度
    e := num[1:4]
    fmt.Println(e)
    fmt.Printf("%T\n", e)
    // 基于切片得到切片
    f := e[0:1]
    fmt.Println(f)
    fmt.Printf("%T\n", f)
    // make函数创建切片,参数 类型,长度,容量(可省略,省略后容量与长度相同)
    g := make([]int, 5, 10)
    h := make([]int, 6)
    i := append(g, 5)
    fmt.Println(g)
    fmt.Println(h)
    fmt.Println(i)
    fmt.Printf("%T\n", g)
    // 切片是对数组的封装,len获取长度
    fmt.Println(len(g))
    // cap获取切片的容量
    fmt.Println(cap(g))
    // nil指仅声明为切片,未初始化.切片仅能与nil使用==,引用类型
    var l []int
    fmt.Println(l, len(l), cap(l))
    if l == nil {
        fmt.Println("l==nil")
    }
    var m = []int{} //声明并初始化,初始化完成的切片不是nil
    fmt.Println(m, len(m), cap(m))
    if m == nil {
        fmt.Println("m==nil")
    }
    n := make([]int, 0)
    fmt.Println(n, len(n), cap(n))
    if n == nil {
        fmt.Println("n==nil")
    }
    // 切片的赋值拷贝
    x := make([]int, 5, 10)
    // 此处y与x公用一个底层数组
    y := x
    y[0] = 100
    fmt.Println(x, y)
    // 切片的扩容
    var ints []int
    // 切片要初始化后才能使用
    //ints[0]=100
    // append函数在添加数据的时候会完成初始化,也有可能会扩容,所以需要变量来接收
    /*ints = append(ints, 10)
    ints = append(ints, 20)
    fmt.Println(ints)*/
    /*使用append向切片添加内容时,初始化或者扩容发生时引用地址会发生改变,就相当于发生了复制旧切片值填入扩容后新创建的切片的过程,
    如果添加时切片已经完成了初始化,添加的内容会跟在长度索引后方,如长度5,容量8,第一次添加的时候就会放在index为5的位置,就是第6个元素
    */
    fmt.Printf("%v len:%d cap:%d ptr:%p\n", ints, len(ints), cap(ints), ints) // 未申请内存空间,初始地址0x0
    for i := 0; i < 10; i++ {
        ints = append(ints, i)
        fmt.Printf("%v len:%d cap:%d ptr:%p\n", ints, len(ints), cap(ints), ints)
    }
    ints = append(ints, 10, 11, 12, 13, 14, 15)
    fmt.Printf("%v len:%d cap:%d ptr:%p\n", ints, len(ints), cap(ints), ints)
    // 将另一个切片中的内容逐个添加
    p := []int{16, 17, 18, 19}
    // 注意需要加上3个点
    ints = append(ints, p...)
    fmt.Printf("%v len:%d cap:%d ptr:%p\n", ints, len(ints), cap(ints), ints)
    // copy,虽然是复制,指向的地址不同
    q := make([]int, 4, 8)
    copy(q, p)
    q[0] = 100
    fmt.Println(p)
    fmt.Println(q)
    // 删除元素,没有直接的方法,可以通过append方法实现
    r := []string{"北京", "上海", "广州", "上海", "深圳", "杭州"}
    // 删除北京,即使用切片中获取切片的方法获取删除前后的两个切片,然后将两个切片合成一个
    r = append(r[:0], r[1:]...)
    fmt.Println(r)
}

